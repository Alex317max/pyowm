py37 create: /home/jwmelvin/pyowm/tests/integration/.tox/py37
ERROR: InterpreterNotFound: python3.7
py38 installed: attrs==19.3.0,certifi==2020.6.20,chardet==3.0.4,geojson==2.5.0,idna==2.9,more-itertools==8.4.0,packaging==20.4,pkg-resources==0.0.0,pluggy==0.13.1,py==1.9.0,pyparsing==2.4.7,PySocks==1.7.1,pytest==5.4.3,requests==2.24.0,six==1.15.0,urllib3==1.25.9,wcwidth==0.2.5
py38 runtests: PYTHONHASHSEED='1521374638'
py38 runtests: commands[0] | pytest .
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1
rootdir: /home/jwmelvin/pyowm
collected 65 items

agroapi10/test_integration_polygons_api_subset.py .                      [  1%]
agroapi10/test_integration_satellite_imagery_download.py FFFF            [  7%]
agroapi10/test_integration_satellite_imagery_search.py .FFFF.            [ 16%]
agroapi10/test_integration_satellite_imagery_stats.py F                  [ 18%]
agroapi10/test_integration_soil_data.py .                                [ 20%]
alertapi30/test_integration_alertapi30.py F                              [ 21%]
commons/test_http_client.py .F...F..                                     [ 33%]
commons/test_image.py ..                                                 [ 36%]
pollutionapi30/test_integration_pollutionapi30.py FFFF                   [ 43%]
stationsapi30/test_integration_stationsapi30.py ..                       [ 46%]
stationsapi30/test_persistence_backends_read_fs.py ...                   [ 50%]
tiles/test_integration_tile_manager.py .                                 [ 52%]
utils/test_default_config.py .                                           [ 53%]
utils/test_integration_config.py .                                       [ 55%]
uvindexapi30/test_integration_uvindexapi30.py ...                        [ 60%]
weatherapi25/test_cityidregistry_reads_fs.py ........                    [ 72%]
weatherapi25/test_integration.py ......F...........                      [100%]

=================================== FAILURES ===================================
________ IntegrationTestsSatelliteImageryDownload.test_download_geotiff ________

self = <tests.integration.agroapi10.test_integration_satellite_imagery_download.IntegrationTestsSatelliteImageryDownload testMethod=test_download_geotiff>

    def test_download_geotiff(self):
        mgr = self.__owm.agro_manager()
    
        # search GeoTiff, EVIimages acquired by Landsat 8
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  ImageTypeEnum.GEOTIFF, PresetEnum.EVI, None, None,
                                                  SatelliteEnum.LANDSAT_8.symbol, None, None, None, None)
        self.assertIsInstance(result_set, list)
        self.assertEqual(len(result_set), 11)
    
        # download one
>       result = mgr.download_satellite_image(result_set[0], palette=PaletteEnum.CONTRAST_SHIFTED)

agroapi10/test_integration_satellite_imagery_download.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/agroapi10/agro_manager.py:285: in download_satellite_image
    status, data = self.http_client.get_geotiff(
../../pyowm/commons/http_client.py:194: in get_geotiff
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = 'Not Found'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
__________ IntegrationTestsSatelliteImageryDownload.test_download_png __________

self = <tests.integration.agroapi10.test_integration_satellite_imagery_download.IntegrationTestsSatelliteImageryDownload testMethod=test_download_png>

    def test_download_png(self):
        mgr = self.__owm.agro_manager()
    
        # search PNG, truecolor, non-tile images acquired by Landsat 8
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  ImageTypeEnum.PNG, PresetEnum.TRUE_COLOR, None, None,
                                                  SatelliteEnum.LANDSAT_8.symbol, None, None, None, None)
        self.assertIsInstance(result_set, list)
        self.assertEqual(len(result_set), 22)
    
        # just keep the non-tile images
        non_tile_pngs = [mimg for mimg in result_set if isinstance(mimg, MetaPNGImage)]
        self.assertEqual(len(non_tile_pngs), 11)
    
        # download one
>       result = mgr.download_satellite_image(non_tile_pngs[0])

agroapi10/test_integration_satellite_imagery_download.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/agroapi10/agro_manager.py:278: in download_satellite_image
    status, data = self.http_client.get_png(
../../pyowm/commons/http_client.py:168: in get_png
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = 'Not Found'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
_________ IntegrationTestsSatelliteImageryDownload.test_download_tile __________

self = <tests.integration.agroapi10.test_integration_satellite_imagery_download.IntegrationTestsSatelliteImageryDownload testMethod=test_download_tile>

    def test_download_tile(self):
        mgr = self.__owm.agro_manager()
    
        # search PNG, truecolor, tile images acquired by Landsat 8
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  ImageTypeEnum.PNG, PresetEnum.TRUE_COLOR, None, None,
                                                  SatelliteEnum.LANDSAT_8.symbol, None, None, None, None)
        self.assertIsInstance(result_set, list)
        self.assertEqual(len(result_set), 22)
    
        # just keep the tiles
        tile_pngs = [mimg for mimg in result_set if isinstance(mimg, MetaTile)]
        self.assertEqual(len(tile_pngs), 11)
    
        # try to download one without specifying x, y and zoom
        with self.assertRaises(AssertionError):
            mgr.download_satellite_image(tile_pngs[0])
        with self.assertRaises(AssertionError):
            mgr.download_satellite_image(tile_pngs[0], x=1)
        with self.assertRaises(AssertionError):
            mgr.download_satellite_image(tile_pngs[0], x=1, y=2)
    
        # download one
>       result = mgr.download_satellite_image(tile_pngs[1], x=1, y=2, zoom=5)

agroapi10/test_integration_satellite_imagery_download.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/agroapi10/agro_manager.py:295: in download_satellite_image
    status, data = self.http_client.get_png(
../../pyowm/commons/http_client.py:168: in get_png
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = 'Not Found'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
_______ IntegrationTestsSatelliteImageryDownload.test_persisting_to_disk _______

self = <tests.integration.agroapi10.test_integration_satellite_imagery_download.IntegrationTestsSatelliteImageryDownload testMethod=test_persisting_to_disk>

    def test_persisting_to_disk(self):
        path = '%s.tif' % uuid.uuid4()
        mgr = self.__owm.agro_manager()
    
        # search GeoTiff, EVIimages acquired by Landsat 8
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  ImageTypeEnum.GEOTIFF, PresetEnum.EVI, None, None,
                                                  SatelliteEnum.LANDSAT_8.symbol, None, None, None, None)
        self.assertTrue(len(result_set) > 1)
        metaimg = result_set[0]
>       sat_img = mgr.download_satellite_image(metaimg)

agroapi10/test_integration_satellite_imagery_download.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/agroapi10/agro_manager.py:285: in download_satellite_image
    status, data = self.http_client.get_geotiff(
../../pyowm/commons/http_client.py:194: in get_geotiff
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = 'Not Found'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
____________ IntegrationTestsSatelliteImagerySearch.test_search_all ____________

self = <tests.integration.agroapi10.test_integration_satellite_imagery_search.IntegrationTestsSatelliteImagerySearch testMethod=test_search_all>

    def test_search_all(self):
        mgr = self.__owm.agro_manager()
    
        # search all images in the specified time frame
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to)
        self.assertIsInstance(result_set, list)
>       self.assertEqual(len(result_set), 360)
E       AssertionError: 372 != 360

agroapi10/test_integration_satellite_imagery_search.py:47: AssertionError
__ IntegrationTestsSatelliteImagerySearch.test_search_for_falsecolor_png_only __

self = <tests.integration.agroapi10.test_integration_satellite_imagery_search.IntegrationTestsSatelliteImagerySearch testMethod=test_search_for_falsecolor_png_only>

    def test_search_for_falsecolor_png_only(self):
        mgr = self.__owm.agro_manager()
    
        # search all PNG images in falsecolor in the specified time frame
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to, ImageTypeEnum.PNG,
                                                  PresetEnum.FALSE_COLOR, None, None, None, None, None, None, None)
        self.assertIsInstance(result_set, list)
>       self.assertEqual(len(result_set), 60)
E       AssertionError: 62 != 60

agroapi10/test_integration_satellite_imagery_search.py:87: AssertionError
___ IntegrationTestsSatelliteImagerySearch.test_search_for_geotiff_type_only ___

self = <tests.integration.agroapi10.test_integration_satellite_imagery_search.IntegrationTestsSatelliteImagerySearch testMethod=test_search_for_geotiff_type_only>

    def test_search_for_geotiff_type_only(self):
        mgr = self.__owm.agro_manager()
    
        # search all geotiff images in the specified time frame
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  ImageTypeEnum.GEOTIFF, None, None, None, None, None, None, None, None)
        self.assertIsInstance(result_set, list)
>       self.assertEqual(len(result_set), 120)
E       AssertionError: 124 != 120

agroapi10/test_integration_satellite_imagery_search.py:67: AssertionError
___ IntegrationTestsSatelliteImagerySearch.test_search_for_ndvi_preset_only ____

self = <tests.integration.agroapi10.test_integration_satellite_imagery_search.IntegrationTestsSatelliteImagerySearch testMethod=test_search_for_ndvi_preset_only>

    def test_search_for_ndvi_preset_only(self):
        mgr = self.__owm.agro_manager()
    
        # search all NDVI images in the specified time frame
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to,
                                                  None, PresetEnum.NDVI, None, None, None, None, None, None, None)
        self.assertIsInstance(result_set, list)
>       self.assertEqual(len(result_set), 90)
E       AssertionError: 93 != 90

agroapi10/test_integration_satellite_imagery_search.py:77: AssertionError
_____ IntegrationTestsSatelliteImageryStats.test_stats_for_satellite_image _____

self = <tests.integration.agroapi10.test_integration_satellite_imagery_stats.IntegrationTestsSatelliteImageryStats testMethod=test_stats_for_satellite_image>

    def test_stats_for_satellite_image(self):
        mgr = self.__owm.agro_manager()
    
        # search all Landsat 8 images in the specified time frame and with high valid data percentage
        result_set = mgr.search_satellite_imagery(self.__polygon.id, self.__acquired_from, self.__acquired_to, None, None,
                                                  None, None, SatelliteEnum.LANDSAT_8.symbol, None, 0.5, 99.5, None)
        self.assertIsInstance(result_set, list)
        self.assertTrue(all([isinstance(i, MetaImage) and i.satellite_name == SatelliteEnum.LANDSAT_8.name for i in result_set]))
    
        # only keep EVI and NDVI ones
        ndvi_only = [mimg for mimg in result_set if mimg.preset == PresetEnum.NDVI]
        evi_only = [mimg for mimg in result_set if mimg.preset == PresetEnum.EVI]
    
        self.assertTrue(len(ndvi_only) > 1)
        self.assertTrue(len(evi_only) > 1)
    
        # now search for stats for both types
>       stats_ndvi = mgr.stats_for_satellite_image(ndvi_only[0])

agroapi10/test_integration_satellite_imagery_stats.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/agroapi10/agro_manager.py:316: in stats_for_satellite_image
    status, data = self.http_client.get_json(metaimage.stats_url, params={})
../../pyowm/commons/http_client.py:143: in get_json
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = 'Not Found'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
________________ IntegrationTestsAlertAPI30.test_triggers_CRUD _________________

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
conn = <urllib3.connection.HTTPSConnection object at 0x7f4c0945d6d0>
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
timeout = Timeout(connect=5, read=5, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=5, read=5, total=None), read_timeout = 5

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
            conn.request(method, url, **httplib_request_kw)
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
                    httplib_response = conn.getresponse()
                except BaseException as e:
                    # Remove the TypeError from the exception chain in
                    # Python 3 (including for exceptions like SystemExit).
                    # Otherwise it looks like a bug in the code.
>                   six.raise_from(e, None)

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = None, from_value = None

>   ???

<string>:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
conn = <urllib3.connection.HTTPSConnection object at 0x7f4c0945d6d0>
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
timeout = Timeout(connect=5, read=5, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=5, read=5, total=None), read_timeout = 5

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
            conn.request(method, url, **httplib_request_kw)
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
>                   httplib_response = conn.getresponse()

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:421: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPSConnection object at 0x7f4c0945d6d0>

    def getresponse(self):
        """Get the response from the server.
    
        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        the response_class variable.
    
        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        """
    
        # if a prior response has been completed, then forget about it.
        if self.__response and self.__response.isclosed():
            self.__response = None
    
        # if a prior response exists, then it must be completed (otherwise, we
        # cannot read this response's header to determine the connection-close
        # behavior)
        #
        # note: if a prior response existed, but was connection-close, then the
        # socket and response were made independent of this HTTPConnection
        # object since a new request requires that we open a whole new
        # connection
        #
        # this means the prior response had one of two states:
        #   1) will_close: this connection was reset and the prior socket and
        #                  response operate independently
        #   2) persistent: the response was retained and we await its
        #                  isclosed() status to become true.
        #
        if self.__state != _CS_REQ_SENT or self.__response:
            raise ResponseNotReady(self.__state)
    
        if self.debuglevel > 0:
            response = self.response_class(self.sock, self.debuglevel,
                                           method=self._method)
        else:
            response = self.response_class(self.sock, method=self._method)
    
        try:
            try:
>               response.begin()

/usr/lib/python3.8/http/client.py:1347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7f4c0945da90>

    def begin(self):
        if self.headers is not None:
            # we've already started reading the response
            return
    
        # read until we get a non-100 response
        while True:
>           version, status, reason = self._read_status()

/usr/lib/python3.8/http/client.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7f4c0945da90>

    def _read_status(self):
>       line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")

/usr/lib/python3.8/http/client.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7f4c0945d370>
b = <memory at 0x7f4c09aa0c40>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)

/usr/lib/python3.8/socket.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
buffer = <memory at 0x7f4c09aa0c40>, nbytes = 8192, flags = 0

    def recv_into(self, buffer, nbytes=None, flags=0):
        self._checkClosed()
        if buffer and (nbytes is None):
            nbytes = len(buffer)
        elif nbytes is None:
            nbytes = 1024
        if self._sslobj is not None:
            if flags != 0:
                raise ValueError(
                  "non-zero flags not allowed in calls to recv_into() on %s" %
                  self.__class__)
>           return self.read(nbytes, buffer)

/usr/lib/python3.8/ssl.py:1241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
len = 8192, buffer = <memory at 0x7f4c09aa0c40>

    def read(self, len=1024, buffer=None):
        """Read up to LEN bytes and return them.
        Return zero-length string on EOF."""
    
        self._checkClosed()
        if self._sslobj is None:
            raise ValueError("Read on closed or unwrapped SSL socket.")
        try:
            if buffer is not None:
>               return self._sslobj.read(len, buffer)
E               socket.timeout: The read operation timed out

/usr/lib/python3.8/ssl.py:1099: timeout

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7f4c093d8520>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=5, read=5, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

.tox/py38/lib/python3.8/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
body = None
headers = {'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=5, read=5, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}, conn = None
release_this_conn = True, err = None, clean_exit = False
timeout_obj = Timeout(connect=5, read=5, total=None), is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else's copy.
        if self.scheme == "http":
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, "No pool connections are available.")
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:724: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
response = None
error = ReadTimeoutError("HTTPSConnectionPool(host='api.openweathermap.org', port=443): Read timed out. (read timeout=5)")
_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
_stacktrace = <traceback object at 0x7f4c09456380>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """ Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
>               raise six.reraise(type(error), error, _stacktrace)

.tox/py38/lib/python3.8/site-packages/urllib3/util/retry.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tp = <class 'urllib3.exceptions.ReadTimeoutError'>, value = None, tb = None

    def reraise(tp, value, tb=None):
        try:
            if value is None:
                value = tp()
            if value.__traceback__ is not tb:
                raise value.with_traceback(tb)
>           raise value

.tox/py38/lib/python3.8/site-packages/urllib3/packages/six.py:735: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
body = None
headers = {'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=5, read=5, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}, conn = None
release_this_conn = True, err = None, clean_exit = False
timeout_obj = Timeout(connect=5, read=5, total=None), is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else's copy.
        if self.scheme == "http":
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
conn = <urllib3.connection.HTTPSConnection object at 0x7f4c0945d6d0>
method = 'DELETE'
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
timeout = Timeout(connect=5, read=5, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Type': 'application/json', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=5, read=5, total=None), read_timeout = 5

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
            conn.request(method, url, **httplib_request_kw)
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
                    httplib_response = conn.getresponse()
                except BaseException as e:
                    # Remove the TypeError from the exception chain in
                    # Python 3 (including for exceptions like SystemExit).
                    # Otherwise it looks like a bug in the code.
                    six.raise_from(e, None)
        except (SocketTimeout, BaseSSLError, SocketError) as e:
>           self._raise_timeout(err=e, url=url, timeout_value=read_timeout)

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:428: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f4c093d8940>
err = timeout('The read operation timed out')
url = '/data/3.0/triggers/5f2d575d14930206c12b4030?APPID=***&lang=en&appid=***'
timeout_value = 5

    def _raise_timeout(self, err, url, timeout_value):
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, "Read timed out. (read timeout=%s)" % timeout_value
            )
E           urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='api.openweathermap.org', port=443): Read timed out. (read timeout=5)

.tox/py38/lib/python3.8/site-packages/urllib3/connectionpool.py:335: ReadTimeoutError

During handling of the above exception, another exception occurred:

self = <pyowm.commons.http_client.HttpClient - root: openweathermap.org/data/3.0>
path = 'triggers/5f2d575d14930206c12b4030'
params = {'APPID': '***', 'appid': '***', 'lang': 'en'}
data = None, headers = {'Content-Type': 'application/json'}

    def delete(self, path, params=None, data=None, headers=None):
        builder = HttpRequestBuilder(self.root_uri, self.api_key, self.config, has_subdomains=self.admits_subdomains)\
            .with_path(path)\
            .with_api_key()\
            .with_language()\
            .with_query_params(params if params is not None else dict())\
            .with_headers(headers if headers is not None else dict())
        url, params, headers, proxies = builder.build()
        try:
>           resp = requests.delete(url, params=params, json=data, headers=headers, proxies=proxies,
                                   timeout=self.config['connection']['timeout_secs'],
                                   verify=self.config['connection']['verify_ssl_certs'])

../../pyowm/commons/http_client.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'https://api.openweathermap.org/data/3.0/triggers/5f2d575d14930206c12b4030'
kwargs = {'headers': {'Content-Type': 'application/json'}, 'json': None, 'params': {'APPID': '***', 'appid': '***', 'lang': 'en'}, 'proxies': {}, ...}

    def delete(url, **kwargs):
        r"""Sends a DELETE request.
    
        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :return: :class:`Response <Response>` object
        :rtype: requests.Response
        """
    
>       return request('delete', url, **kwargs)

.tox/py38/lib/python3.8/site-packages/requests/api.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'delete'
url = 'https://api.openweathermap.org/data/3.0/triggers/5f2d575d14930206c12b4030'
kwargs = {'headers': {'Content-Type': 'application/json'}, 'json': None, 'params': {'APPID': '***', 'appid': '***', 'lang': 'en'}, 'proxies': {}, ...}
session = <requests.sessions.Session object at 0x7f4c093d87c0>

    def request(method, url, **kwargs):
        """Constructs and sends a :class:`Request <Request>`.
    
        :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary, list of tuples or bytes to send
            in the query string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
        :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.
            ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``
            or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content-type'`` is a string
            defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers
            to add for the file.
        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How many seconds to wait for the server to send data
            before giving up, as a float, or a :ref:`(connect timeout, read
            timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
                the server's TLS certificate, or a string, in which case it must be a path
                to a CA bundle to use. Defaults to ``True``.
        :param stream: (optional) if ``False``, the response content will be immediately downloaded.
        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
        :return: :class:`Response <Response>` object
        :rtype: requests.Response
    
        Usage::
    
          >>> import requests
          >>> req = requests.request('GET', 'https://httpbin.org/get')
          >>> req
          <Response [200]>
        """
    
        # By using the 'with' statement we are sure the session is closed, thus we
        # avoid leaving sockets open which can trigger a ResourceWarning in some
        # cases, and look like a memory leak in others.
        with sessions.Session() as session:
>           return session.request(method=method, url=url, **kwargs)

.tox/py38/lib/python3.8/site-packages/requests/api.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x7f4c093d87c0>, method = 'delete'
url = 'https://api.openweathermap.org/data/3.0/triggers/5f2d575d14930206c12b4030'
params = {'APPID': '***', 'appid': '***', 'lang': 'en'}
data = None, headers = {'Content-Type': 'application/json'}, cookies = None
files = None, auth = None, timeout = 5, allow_redirects = True, proxies = {}
hooks = None, stream = None, verify = True, cert = None, json = None

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        """Constructs a :class:`Request <Request>`, prepares it and sends it.
        Returns :class:`Response <Response>` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``'filename': file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server's TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, ('cert', 'key') pair.
        :rtype: requests.Response
        """
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            'timeout': timeout,
            'allow_redirects': allow_redirects,
        }
        send_kwargs.update(settings)
>       resp = self.send(prep, **send_kwargs)

.tox/py38/lib/python3.8/site-packages/requests/sessions.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x7f4c093d87c0>
request = <PreparedRequest [DELETE]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': 5, ...}
allow_redirects = True, stream = False, hooks = {'response': []}
adapter = <requests.adapters.HTTPAdapter object at 0x7f4c093d8520>
start = 1596807007.6079125

    def send(self, request, **kwargs):
        """Send a given PreparedRequest.
    
        :rtype: requests.Response
        """
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault('stream', self.stream)
        kwargs.setdefault('verify', self.verify)
        kwargs.setdefault('cert', self.cert)
        kwargs.setdefault('proxies', self.proxies)
    
        # It's possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError('You can only send PreparedRequests.')
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop('allow_redirects', True)
        stream = kwargs.get('stream')
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
>       r = adapter.send(request, **kwargs)

.tox/py38/lib/python3.8/site-packages/requests/sessions.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7f4c093d8520>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=5, read=5, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
            raise ConnectionError(e, request=request)
    
        except ClosedPoolError as e:
            raise ConnectionError(e, request=request)
    
        except _ProxyError as e:
            raise ProxyError(e)
    
        except (_SSLError, _HTTPError) as e:
            if isinstance(e, _SSLError):
                # This branch is for urllib3 versions earlier than v1.22
                raise SSLError(e, request=request)
            elif isinstance(e, ReadTimeoutError):
>               raise ReadTimeout(e, request=request)
E               requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='api.openweathermap.org', port=443): Read timed out. (read timeout=5)

.tox/py38/lib/python3.8/site-packages/requests/adapters.py:529: ReadTimeout

During handling of the above exception, another exception occurred:

self = <tests.integration.alertapi30.test_integration_alertapi30.IntegrationTestsAlertAPI30 testMethod=test_triggers_CRUD>

    def test_triggers_CRUD(self):
    
        mgr = self.__owm.alert_manager()
    
        # check if any previous triggers exist on this account
        n_old_triggers = len(mgr.get_triggers())
    
        # create trigger1
        trigger1 = mgr.create_trigger(self.start, self.end, conditions=[self.cond1], area=[self.area1])
    
        # create trigger2
        trigger2 = mgr.create_trigger(self.start, self.end, conditions=[self.cond2], area=[self.area2])
    
        # Read all created triggers
        triggers = mgr.get_triggers()
        self.assertEqual(n_old_triggers + 2, len(triggers))
    
        # Read one by one
        result = mgr.get_trigger(trigger1.id)
        self.assertEqual(trigger1.id, result.id)
        self.assertEqual(trigger1.start_after_millis, result.start_after_millis)
        self.assertEqual(trigger1.end_after_millis, result.end_after_millis)
        self.assertEqual(len(trigger1.conditions), len(result.conditions))
        self.assertEqual(len(trigger1.area), len(result.area))
    
        result = mgr.get_trigger(trigger2.id)
        self.assertEqual(trigger2.id, result.id)
        self.assertEqual(trigger2.start_after_millis, result.start_after_millis)
        self.assertEqual(trigger2.end_after_millis, result.end_after_millis)
        self.assertEqual(len(trigger2.conditions), len(result.conditions))
        self.assertEqual(len(trigger2.area), len(result.area))
    
        # Update a trigger
        modified_trigger2 = copy.deepcopy(trigger2)
        modified_trigger2.conditions = [self.cond1, self.cond2]
    
        mgr.update_trigger(modified_trigger2)
        result = mgr.get_trigger(modified_trigger2.id)
    
        self.assertEqual(modified_trigger2.id, result.id)
        self.assertEqual(modified_trigger2.start_after_millis, result.start_after_millis)
        self.assertEqual(modified_trigger2.end_after_millis, result.end_after_millis)
        self.assertEqual(len(modified_trigger2.area), len(result.area))
        # of course, conditions have been modified with respect to former trigger 2
        self.assertNotEqual(len(trigger2.conditions), len(result.conditions))
        self.assertEqual(len(modified_trigger2.conditions), len(result.conditions))
    
        # Delete triggers one by one
>       mgr.delete_trigger(trigger1)

alertapi30/test_integration_alertapi30.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/alertapi30/alert_manager.py:166: in delete_trigger
    status, _ = self.http_client.delete(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyowm.commons.http_client.HttpClient - root: openweathermap.org/data/3.0>
path = 'triggers/5f2d575d14930206c12b4030'
params = {'APPID': '***', 'appid': '***', 'lang': 'en'}
data = None, headers = {'Content-Type': 'application/json'}

    def delete(self, path, params=None, data=None, headers=None):
        builder = HttpRequestBuilder(self.root_uri, self.api_key, self.config, has_subdomains=self.admits_subdomains)\
            .with_path(path)\
            .with_api_key()\
            .with_language()\
            .with_query_params(params if params is not None else dict())\
            .with_headers(headers if headers is not None else dict())
        url, params, headers, proxies = builder.build()
        try:
            resp = requests.delete(url, params=params, json=data, headers=headers, proxies=proxies,
                                   timeout=self.config['connection']['timeout_secs'],
                                   verify=self.config['connection']['verify_ssl_certs'])
        except requests.exceptions.SSLError as e:
            raise exceptions.InvalidSSLCertificateError(str(e))
        except requests.exceptions.ConnectionError as e:
            raise exceptions.InvalidSSLCertificateError(str(e))
        except requests.exceptions.Timeout:
>           raise exceptions.TimeoutError('API call timeouted')
E           pyowm.commons.exceptions.TimeoutError: API call timeouted

../../pyowm/commons/http_client.py:270: TimeoutError
_______________________ TestHTTPClient.test_get_geotiff ________________________

self = <tests.integration.commons.test_http_client.TestHTTPClient testMethod=test_get_geotiff>

    def test_get_geotiff(self):
        # https://download.osgeo.org/geotiff/samples/made_up/bogota.tif
>       status, data = self.instance.get_geotiff('https://download.osgeo.org/geotiff/samples/made_up/bogota.tif')

commons/test_http_client.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/commons/http_client.py:194: in get_geotiff
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server.  If you entered the URL manually please check your spelling and try again.</p>\n'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
_________________________ TestHTTPClient.test_get_png __________________________

self = <tests.integration.commons.test_http_client.TestHTTPClient testMethod=test_get_png>

    def test_get_png(self):
        # http://httpbin.org/image/png
>       status, data = self.instance.get_png('http://httpbin.org/image/png')

commons/test_http_client.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../pyowm/commons/http_client.py:168: in get_png
    HttpClient.check_status_code(resp.status_code, resp.text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pyowm.commons.http_client.HttpClient'>, status_code = 404
payload = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server.  If you entered the URL manually please check your spelling and try again.</p>\n'

    @classmethod
    def check_status_code(cls, status_code, payload):
        if status_code < 400:
            return
        if status_code == 400:
            raise exceptions.APIRequestError(payload)
        elif status_code == 401:
            raise exceptions.UnauthorizedError('Invalid API Key provided')
        elif status_code == 404:
>           raise exceptions.NotFoundError('Unable to find the resource')
E           pyowm.commons.exceptions.NotFoundError: Unable to find the resource

../../pyowm/commons/http_client.py:288: NotFoundError
__________ IntegrationTestsPollutionAPI30.test_coindex_around_coords ___________

self = <tests.integration.pollutionapi30.test_integration_pollutionapi30.IntegrationTestsPollutionAPI30 testMethod=test_coindex_around_coords>

    def test_coindex_around_coords(self):
        """
        Test feature: get CO index around geo-coordinates.
        """
        u = self.__owm.coindex_around_coords(45, 9)
        self.assertIsNotNone(u)
        self.assertIsNotNone(u.co_samples)
        self.assertIsNotNone(u.reception_time())
        self.assertIsNotNone(u.reference_time())
>       self.assertIsNone(u.interval)
E       AssertionError: 'year' is not None

pollutionapi30/test_integration_pollutionapi30.py:22: AssertionError
__________ IntegrationTestsPollutionAPI30.test_no2index_around_coords __________

self = <tests.integration.pollutionapi30.test_integration_pollutionapi30.IntegrationTestsPollutionAPI30 testMethod=test_no2index_around_coords>

    def test_no2index_around_coords(self):
        """
        Test feature: get NO2 index around geo-coordinates.
        """
        u = self.__owm.no2index_around_coords(0.0, 10.0, start='2016-12-31 12:55:55+00:00')
        self.assertIsNotNone(u)
        self.assertIsNotNone(u.no2_samples)
        self.assertIsNotNone(u.reception_time())
        self.assertIsNotNone(u.reference_time())
>       self.assertIsNone(u.interval)
E       AssertionError: 'year' is not None

pollutionapi30/test_integration_pollutionapi30.py:46: AssertionError
___________ IntegrationTestsPollutionAPI30.test_ozone_around_coords ____________

self = <tests.integration.pollutionapi30.test_integration_pollutionapi30.IntegrationTestsPollutionAPI30 testMethod=test_ozone_around_coords>

    def test_ozone_around_coords(self):
        """
        Test feature: get ozone around geo-coordinates.
        """
        u = self.__owm.ozone_around_coords(0.0, 10.0, start='2016-12-31 12:55:55+00:00')
        self.assertIsNotNone(u)
        self.assertIsNotNone(u.du_value)
        self.assertIsNotNone(u.reception_time())
        self.assertIsNotNone(u.reference_time())
>       self.assertIsNone(u.interval)
E       AssertionError: 'year' is not None

pollutionapi30/test_integration_pollutionapi30.py:34: AssertionError
__________ IntegrationTestsPollutionAPI30.test_so2index_around_coords __________

self = <tests.integration.pollutionapi30.test_integration_pollutionapi30.IntegrationTestsPollutionAPI30 testMethod=test_so2index_around_coords>

    def test_so2index_around_coords(self):
        """
        Test feature: get SO2 index around geo-coordinates.
        """
        u = self.__owm.so2index_around_coords(0.0, 10.0, start='2016-12-31 12:55:55+00:00')
        self.assertIsNotNone(u)
        self.assertIsNotNone(u.so2_samples)
        self.assertIsNotNone(u.reception_time())
        self.assertIsNotNone(u.reference_time())
>       self.assertIsNone(u.interval)
E       AssertionError: 'year' is not None

pollutionapi30/test_integration_pollutionapi30.py:58: AssertionError
______________ IntegrationTestsWebAPI25.test_one_call_historical _______________

self = <tests.integration.weatherapi25.test_integration.IntegrationTestsWebAPI25 testMethod=test_one_call_historical>

    def test_one_call_historical(self):
        result = self.__owm.one_call_history(lat=46.49, lon=11.33)
        self.assertTrue(isinstance(result, OneCall))
        self.assertEqual(46.49, result.lat)
        self.assertEqual(11.33, result.lon)
        self.assertEqual("Europe/Rome", result.timezone)
        self.assertTrue(isinstance(result.current, Weather))
        for i, weather in enumerate(result.forecast_hourly):
            self.assertTrue(isinstance(weather, Weather), f"entry {i} of forecast_hourly is invalid")
>       self.assertEqual(8, len(result.forecast_daily))
E       TypeError: object of type 'NoneType' has no len()

weatherapi25/test_integration.py:449: TypeError
=============================== warnings summary ===============================
.tox/py38/lib/python3.8/site-packages/pkg_resources/_vendor/pyparsing.py:943
  /home/jwmelvin/pyowm/tests/integration/.tox/py38/lib/python3.8/site-packages/pkg_resources/_vendor/pyparsing.py:943: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated since Python 3.3, and in 3.9 it will stop working
    collections.MutableMapping.register(ParseResults)

.tox/py38/lib/python3.8/site-packages/pkg_resources/_vendor/pyparsing.py:3226
  /home/jwmelvin/pyowm/tests/integration/.tox/py38/lib/python3.8/site-packages/pkg_resources/_vendor/pyparsing.py:3226: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated since Python 3.3, and in 3.9 it will stop working
    elif isinstance( exprs, collections.Iterable ):

-- Docs: https://docs.pytest.org/en/latest/warnings.html
=========================== short test summary info ============================
FAILED agroapi10/test_integration_satellite_imagery_download.py::IntegrationTestsSatelliteImageryDownload::test_download_geotiff
FAILED agroapi10/test_integration_satellite_imagery_download.py::IntegrationTestsSatelliteImageryDownload::test_download_png
FAILED agroapi10/test_integration_satellite_imagery_download.py::IntegrationTestsSatelliteImageryDownload::test_download_tile
FAILED agroapi10/test_integration_satellite_imagery_download.py::IntegrationTestsSatelliteImageryDownload::test_persisting_to_disk
FAILED agroapi10/test_integration_satellite_imagery_search.py::IntegrationTestsSatelliteImagerySearch::test_search_all
FAILED agroapi10/test_integration_satellite_imagery_search.py::IntegrationTestsSatelliteImagerySearch::test_search_for_falsecolor_png_only
FAILED agroapi10/test_integration_satellite_imagery_search.py::IntegrationTestsSatelliteImagerySearch::test_search_for_geotiff_type_only
FAILED agroapi10/test_integration_satellite_imagery_search.py::IntegrationTestsSatelliteImagerySearch::test_search_for_ndvi_preset_only
FAILED agroapi10/test_integration_satellite_imagery_stats.py::IntegrationTestsSatelliteImageryStats::test_stats_for_satellite_image
FAILED alertapi30/test_integration_alertapi30.py::IntegrationTestsAlertAPI30::test_triggers_CRUD
FAILED commons/test_http_client.py::TestHTTPClient::test_get_geotiff - pyowm....
FAILED commons/test_http_client.py::TestHTTPClient::test_get_png - pyowm.comm...
FAILED pollutionapi30/test_integration_pollutionapi30.py::IntegrationTestsPollutionAPI30::test_coindex_around_coords
FAILED pollutionapi30/test_integration_pollutionapi30.py::IntegrationTestsPollutionAPI30::test_no2index_around_coords
FAILED pollutionapi30/test_integration_pollutionapi30.py::IntegrationTestsPollutionAPI30::test_ozone_around_coords
FAILED pollutionapi30/test_integration_pollutionapi30.py::IntegrationTestsPollutionAPI30::test_so2index_around_coords
FAILED weatherapi25/test_integration.py::IntegrationTestsWebAPI25::test_one_call_historical
================== 17 failed, 48 passed, 2 warnings in 49.59s ==================
ERROR: InvocationError: '/home/jwmelvin/pyowm/tests/integration/.tox/py38/bin/pytest .'
___________________________________ summary ____________________________________
SKIPPED:  py37: InterpreterNotFound: python3.7
ERROR:   py38: commands failed
